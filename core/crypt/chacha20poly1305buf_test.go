package crypt

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
)

func Test_MakeChaCha20Poly1305Buf(t *testing.T) {
	t.Parallel()
	add := [...]byte{
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
	}
	salt := [...]byte{
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
	}
	ciphertext := bytes.Repeat([]byte{0xcc}, 7)
	expBuf := &ChaCha20Poly1305Buf{
		block: []byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
		},
	}

	buf := MakeChaCha20Poly1305Buf(add, salt, ciphertext)
	assert.Equal(t, expBuf, buf)
}

func Test_LoadChaCha20Poly1305Buf(t *testing.T) {
	t.Parallel()
	t.Run("ErrInvalidBufferStructure error", func(t *testing.T) {
		t.Parallel()
		block := []byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		}
		var expBuf *ChaCha20Poly1305Buf = nil
		expErr := ErrInvalidBufferStructure

		buf, err := LoadChaCha20Poly1305Buf(block)
		assert.Equal(t, expBuf, buf)
		assert.ErrorIs(t, err, expErr)
	})
	t.Run("Succeed", func(t *testing.T) {
		t.Parallel()
		block := []byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
		}
		expBuf := &ChaCha20Poly1305Buf{block: block}

		buf, err := LoadChaCha20Poly1305Buf(block)
		assert.Equal(t, expBuf, buf)
		assert.ErrorIs(t, err, nil)
	})
}

func Test_ChaCha20Poly1305Buf_Add(t *testing.T) {
	t.Parallel()
	buf := &ChaCha20Poly1305Buf{
		block: []byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
		},
	}
	expAdd := bytes.Repeat([]byte{0xaa}, ChaCha20Poly1305AddLen)

	add := buf.Add()
	assert.Equal(t, expAdd, add)
}

func Test_ChaCha20Poly1305Buf_Salt(t *testing.T) {
	t.Parallel()
	buf := &ChaCha20Poly1305Buf{
		block: []byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
		},
	}
	expSalt := bytes.Repeat([]byte{0xbb}, ChaCha20Poly1305SaltLen)

	salt := buf.Salt()
	assert.Equal(t, expSalt, salt)
}

func Test_ChaCha20Poly1305Buf_Ciphertext(t *testing.T) {
	t.Parallel()
	buf := &ChaCha20Poly1305Buf{
		block: []byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
		},
	}
	expCiphertext := bytes.Repeat([]byte{0xcc}, 7)

	ciphertext := buf.Ciphertext()
	assert.Equal(t, expCiphertext, ciphertext)
}

func Test_ChaCha20Poly1305Buf_Block(t *testing.T) {
	t.Parallel()
	expBlock := []byte{
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
	}
	buf := &ChaCha20Poly1305Buf{block: expBlock}

	block := buf.Block()
	assert.Equal(t, expBlock, block)
}
