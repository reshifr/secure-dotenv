package crypt

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
)

func Test_MakeChaCha20Poly1305Buf(t *testing.T) {
	t.Parallel()
	t.Run("ErrInvalidAddLen error", func(t *testing.T) {
		t.Parallel()
		add := bytes.Repeat([]byte{0xaa}, 8)
		salt := bytes.Repeat([]byte{0xbb}, ChaCha20Poly1305SaltLen)
		ciphertext := bytes.Repeat([]byte{0xcc}, 7)
		var expBuf *ChaCha20Poly1305Buf = nil
		expErr := ErrInvalidAddLen

		buf, err := MakeChaCha20Poly1305Buf(add, salt, ciphertext)
		assert.Equal(t, expBuf, buf)
		assert.ErrorIs(t, err, expErr)
	})
	t.Run("ErrInvalidSaltLen error", func(t *testing.T) {
		t.Parallel()
		add := bytes.Repeat([]byte{0xaa}, ChaCha20Poly1305AddLen)
		salt := bytes.Repeat([]byte{0xbb}, 8)
		ciphertext := bytes.Repeat([]byte{0xcc}, 7)
		var expBuf *ChaCha20Poly1305Buf = nil
		expErr := ErrInvalidSaltLen

		buf, err := MakeChaCha20Poly1305Buf(add, salt, ciphertext)
		assert.Equal(t, expBuf, buf)
		assert.ErrorIs(t, err, expErr)
	})
	t.Run("Succeed", func(t *testing.T) {
		t.Parallel()
		add := bytes.Repeat([]byte{0xaa}, ChaCha20Poly1305AddLen)
		salt := bytes.Repeat([]byte{0xbb}, ChaCha20Poly1305SaltLen)
		ciphertext := bytes.Repeat([]byte{0xcc}, 7)
		expBuf := &ChaCha20Poly1305Buf{
			buf: []byte{
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
				0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
				0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
				0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
				0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
				0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
			},
		}

		buf, err := MakeChaCha20Poly1305Buf(add, salt, ciphertext)
		assert.Equal(t, expBuf, buf)
		assert.ErrorIs(t, err, nil)
	})
}

func Test_LoadChaCha20Poly1305Buf(t *testing.T) {
	t.Parallel()
	t.Run("ErrInvalidBufferStructure error", func(t *testing.T) {
		t.Parallel()
		buf := []byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
		}
		var expCPBuf *ChaCha20Poly1305Buf = nil
		expErr := ErrInvalidBufferStructure

		cpBuf, err := LoadChaCha20Poly1305Buf(buf)
		assert.Equal(t, expCPBuf, cpBuf)
		assert.ErrorIs(t, err, expErr)
	})
	t.Run("Succeed", func(t *testing.T) {
		t.Parallel()
		buf := []byte{
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
			0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
		}
		expCPBuf := &ChaCha20Poly1305Buf{buf: buf}

		cpBuf, err := LoadChaCha20Poly1305Buf(buf)
		assert.Equal(t, expCPBuf, cpBuf)
		assert.ErrorIs(t, err, nil)
	})
}
